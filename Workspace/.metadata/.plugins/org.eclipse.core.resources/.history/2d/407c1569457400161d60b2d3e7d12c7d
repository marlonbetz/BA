from pipeline import *
from string_distances import *
print("LOAD TEST WORDLIST")
pathToAnnotatedWordList = "Data/IELex/output/IELex-2016.tsv.asjp"

languages,words,global_ids,cognate_classes = loadAnnotatedWordList(pathToAnnotatedWordList, None)

concepts2words = dict((concept,[word for i,word in enumerate(words) if global_ids[i] == concept]) for concept in set(sorted(global_ids)))
concepts2cognate_classes = dict((concept,[cog for i,cog in enumerate(cognate_classes) if global_ids[i] == concept]) for concept in set(sorted(global_ids)))

for concept concepts2words:
    words_tmp = concepts2words[concept]
    y_true = concepts2cognate_classes[concept]

    
    dists = np.zeros((len(words),len(words)))
    
    for i1,w1 in enumerate(words):
        for i2,w2 in enumerate(words):
            dists[i1,i2] = - normalized_levenshtein(w1, w2)
    
    
    
    damping_factor = 0.5
    
    affinity = "precomputed"
    ap = AffinityPropagation(damping=damping_factor,
                             #preference=pref
                             affinity=affinity
                             )
    
    y_pred = ap.fit_predict(dists)
    n_cognate_classes = len(set(cognate_classes))
    n_concepts = len(set(global_ids))
    y_random = np.random.randint(0,int(n_cognate_classes/n_concepts),y_pred.shape)

print(metrics.adjusted_rand_score(y_true, y_pred))
print(metrics.adjusted_mutual_info_score(y_true, y_pred))
print(metrics.homogeneity_completeness_v_measure(y_true, y_pred))

print(metrics.adjusted_rand_score(y_true, y_random))
print(metrics.adjusted_mutual_info_score(y_true, y_random))
print(metrics.homogeneity_completeness_v_measure(y_true, y_random))


  
print("PLOTTING")
import matplotlib.pyplot as plt
import seaborn as sns
from  scipy.stats import multivariate_normal as mvn


