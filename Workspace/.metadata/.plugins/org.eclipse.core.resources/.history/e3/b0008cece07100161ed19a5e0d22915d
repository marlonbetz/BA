import numpy as np 
import pickle
import codecs

adjusted_rand_scores = pickle.load(,codecs.open("adjusted_rand_scores.pkl","rb"))
adjusted_mutual_info_scores = pickle.load(,codecs.open("adjusted_mutual_info_scores.pkl","rb"))
homogeneity_scores = pickle.load(,codecs.open("homogeneity_scores.pkl","rb"))
completeness_scores = pickle.load(,codecs.open("completeness_scores.pkl","rb"))
v_measures_scores = pickle.load(,codecs.open("v_measures_scores.pkl","rb"))

adjusted_rand_scores_random = pickle.load(,codecs.open("adjusted_rand_scores_random.pkl","rb"))
adjusted_mutual_info_scores_random = pickle.load(,codecs.open("adjusted_mutual_info_scores_random.pkl","rb"))
homogeneity_scores_random = pickle.load(,codecs.open("homogeneity_scores_random.pkl","rb"))
completeness_scores_random = pickle.load(,codecs.open("completeness_scores_random.pkl","rb"))
v_measures_scores_random = pickle.load(,codecs.open("v_measures_scores_random.pkl","rb"))
n_cognate_classes_true_perDataPoint = pickle.load(,codecs.open("n_cognate_classes_true_perDataPoint.pkl","rb"))
n_cognate_classes_pred_perDataPoint = pickle.load(,codecs.open("n_cognate_classes_pred_perDataPoint.pkl","rb"))


ars = pickle.load(codecs.open("adjusted_rand_scores.pkl","rb"))
ami = pickle.load(codecs.open("adjusted_mutual_info_scores.pkl","rb"))
hcv =  np.array(pickle.load(codecs.open("homogeneity_scores.pkl","rb")))
hcv =  np.array(pickle.load(codecs.open("completeness_scores.pkl","rb")))
hcv =  np.array(pickle.load(codecs.open("v_measures_scores.pkl","rb")))
hcv =  np.array(pickle.load(codecs.open("homogeneity_completeness_v_measures_scores.pkl","rb")))
h = hcv[:,0]
c = hcv[:,1]
v = hcv[:,2]
n_true =pickle.load(codecs.open("n_cognate_classes_true_perDataPoint.pkl","rb"))
n_pred =pickle.load(codecs.open("n_cognate_classes_pred_perDataPoint.pkl","rb"))
import matplotlib.pyplot as plt

n_ars_map = dict(
                (n,[ars_ for i,ars_ in enumerate(ars) if n_true[i] == n])
                 for n in n_true
                  )
n_ami_map = dict(
                (n,[ami_ for i,ami_ in enumerate(ami) if n_true[i] == n])
                 for n in n_true
                  )
import seaborn as sns

def plot(y_label):
    x_ticks = ["ARI","AMI","H","C","V"]
    y = []
    for i,data in enumerate([ars,ami,h,c,v]):
        y.append(data[0])
    y=np.array(y)
    print(y.shape)
    plt.boxplot(y.T)
    plt.xticks(range(1,len(x_ticks)+1),x_ticks)
    plt.xlabel("phoneme vectorization")

#plot n_true vs n_pred
#plt.scatter(n_true,n_pred)
#plot distribution of true cognet set size vs ami
#sns.barplot(list(n_ami_map.keys()),[np.mean(n_ami_map[key]) for key in n_ami_map])

#plot distribution of true cognate set sizes
#sns.barplot(list(set(n_true)),[n_true.count(n) for n in list(set(n_true))])
#plt.plot(ars)
plt.show()